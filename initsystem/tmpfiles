#!/bin/ash

# This file is part of initsystem
#
# Copyright (C) 2014-2015 ValÃ¨re Monseur (valere dot monseur at ymail dot com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# From man tmpfiles.d, not implemented:
# - If multiple files specify the same path, the entry in the file with 
# the lexicographically earliest name will be applied, all other
# conflicting entries will be logged as errors.
# - When two lines are prefix and suffix of each other, then the prefix
# is always processed first, the suffix later. Otherwise, the files/directories
# are processed in the order they are listed.
# - Exclamation mark in type is not taken into account.
# - Path with percent sign are skipped.
# - Tilde in mode is not taken into account.
# - Age is not taken into account.
# - In L+ and C types, /usr/share/factory/ is not taken into account
# - x and X types are skipped

# From man systemd-tmpfiles, implemented:
# Accepted parameters: --prefix=path --exclude-prefix=path
# Only one parameter is taken into account

PATH=/opt/busybox

################################################################################
# sanity check #################################################################
################################################################################

if [ `id -u` != 0 ]; then
  echo "error: this script should be run as root"
  exit 1
fi

################################################################################
# parameters ###################################################################
################################################################################

INCLUDE=""; EXCLUDE=""

if [ $# -ge 1 ]; then
  case "$1" in
    --prefix=*)
      INCLUDE=`echo "$1" | cut -d '=' -f 2`
      ;;
    --exclude-prefix=*)
      EXCLUDE=`echo "$1" | cut -d '=' -f 2`
      ;;
  esac
fi

################################################################################
# process tmpfiles #############################################################
################################################################################

DIR1="/usr/lib/tmpfiles.d"
DIR2="/etc/tmpfiles.d"

for FILE in `find "${DIR1}" "${DIR2}" -name *.conf -exec basename '{}' \; 2> /dev/null | sort -u`; do

  [ -r "${DIR1}/${FILE}" ] && IFILE="${DIR1}/${FILE}"
  [ -r "${DIR2}/${FILE}" ] && IFILE="${DIR2}/${FILE}"

  grep -E -v "^[[:blank:]]*(#|$)" "${IFILE}" | while read LINE; do

    TYP=""; PTH=""; MOD=""; UID=""; GID=""; AGE=""; ARG=""

    for FIELD in `echo "${LINE}" | \
      awk -F'"' -v OFS='' '{ for (i=2; i<=NF; i+=2) gsub(" ", "\\\x20", $i) } 1'`; do

      FIELD=`echo -e "${FIELD}"`

      [ -z "${TYP}" ] && TYP="${FIELD}" && continue
      [ -z "${PTH}" ] && PTH="${FIELD}" && continue
      [ -z "${MOD}" ] && MOD="${FIELD}" && continue
      [ -z "${UID}" ] && UID="${FIELD}" && continue
      [ -z "${GID}" ] && GID="${FIELD}" && continue
      [ -z "${AGE}" ] && AGE="${FIELD}" && continue
      [ -z "${ARG}" ] && ARG="${FIELD}" && continue
    done

    # skip included/excluded paths
    [ "${INCLUDE}" ] && [ "${PTH##${INCLUDE}*}" ] && continue
    [ "${EXCLUDE}" ] && [ ! "${PTH##${EXCLUDE}*}" ] && continue

    # remove trailing ! from type
    [ `echo ${TYP} | grep !` ] && TYP="${TYP%?}"

    # skip path with a percent sign
    [ `echo ${PTH} | grep %` ] && continue

    # remove leading ~ from mode
    [ `echo ${MOD} | grep \~` ] && MOD="${MOD#~}"

    [ "${MOD}" = "-" ] && MOD=""
    [ "${UID}" = "-" ] && UID=""
    [ "${GID}" = "-" ] && GID=""
    [ "${AGE}" = "-" ] && AGE=""
    [ "${ARG}" = "-" ] && ARG=""

    [ -z "${TYP}" ] && continue
    [ -z "${PTH}" ] && continue

    case "${TYP}" in

      "f")

        # Create a file if it does not exist yet. If the argument parameter
        # is given, it will be written to the file.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          [ -z "${MOD}" ] && MOD="0644"
          [ -z "${UID}" ] && UID="root"
          [ -z "${GID}" ] && GID="root"
          install -o "${UID}" -g "${GID}" -m "${MOD}" /dev/null "${PTH}"
          [ ! -z "${ARG}" ] && echo "${ARG}" > "${PTH}"
        fi
        ;;

      "F")

        # Create or truncate a file. If the argument parameter is given,
        # it will be written to the file.

        [ -z "${MOD}" ] && MOD="0644"
        [ -z "${UID}" ] && UID="root"
        [ -z "${GID}" ] && GID="root"
        install -m "${MOD}" -o "${UID}" -g "${GID}" /dev/null "${PTH}"
        [ ! -z "${ARG}" ] && echo "${ARG}" > "${PTH}"
        ;;

      "w")

        # Write the argument parameter to a file, if the file exists. Lines of
        # this type accept shell-style globs in place of normal path names.
        # The argument parameter will be written without a trailing newline.
        # C-style backslash escapes are interpreted.

        if [ -e "${PTH}" ]; then
          [ "${ARG}" ] && echo -n -e "${ARG}" > "${PTH}"
        fi
        ;;

      "d")

        # Create a directory if it does not exist yet.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          [ -z "${MOD}" ] && MOD="0755"
          [ -z "${UID}" ] && UID="root"
          [ -z "${GID}" ] && GID="root"
          install -d -m "${MOD}" -o "${UID}" -g "${GID}" "${PTH}"
        fi
        ;;

      "D")

        # Create or empty a directory.

        if [ -d "${PTH}" ]; then
          find "${PTH}" -mindepth 1 -maxdepth 1 -xdev -print0 | xargs -r0 rm -rf
        fi
        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          [ -z "${MOD}" ] && MOD="0755"
          [ -z "${UID}" ] && UID="root"
          [ -z "${GID}" ] && GID="root"
          install -d -m "${MOD}" -o "${UID}" -g "${GID}" "${PTH}"
        fi
        ;;

      "p")

        # Create a named pipe (FIFO) if it does not exist yet.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          [ -z "${MOD}" ] && MOD="0644"
          [ -z "${UID}" ] && UID="root"
          [ -z "${GID}" ] && GID="root"
          mkfifo -m "${MOD}" "${PTH}"
          chown "${UID}:${GID}" "${PTH}"
        fi
        ;;

      "p+")

        # Create a named pipe (FIFO) if it does not exist yet. If suffixed
        # with + and a file already exists where the pipe is to be created,
        # it will be removed and be replaced by the pipe.

        if [ -e "${PTH}" ] || [ -L "${PTH}" ]; then
          rm -f "${PTH}"
        fi
        [ -z "${MOD}" ] && MOD="0644"
        [ -z "${UID}" ] && UID="root"
        [ -z "${GID}" ] && GID="root"
        mkfifo -m "${MOD}" "${PTH}"
        chown "${UID}:${GID}" "${PTH}"
        ;;

      "L")

        # Create a symlink if it does not exist yet.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          if [ "${ARG}" ]; then
            ln -s "${ARG}" "${PTH}"
          fi
        fi
        ;;

      "L+")

        # Create a symlink if it does not exist yet. If suffixed with + and
        # a file already exists where the symlink is to be created, it will
        # be removed and be replaced by the symlink. If the argument is
        # omitted, symlinks to files with the same name residing in the
        # directory /usr/share/factory/ are created.

        if [ -e "${PTH}" ] || [ -L "${PTH}" ]; then
          rm -f "${PTH}"
        fi
        if [ "${ARG}" ]; then
          ln -s "${ARG}" "${PTH}"
        fi
        ;;

      "c")

        # Create a character device node if it does not exist yet.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          if [ "${ARG}" ]; then
            MAJOR=`echo ${ARG} | cut -d ':' -f 1`
            MINOR=`echo ${ARG} | cut -d ':' -f 2`
            [ -z "${MOD}" ] && MOD="0644"
            [ -z "${UID}" ] && UID="root"
            [ -z "${GID}" ] && GID="root"
            mknod -m "${MOD}" "${PTH}" c "${MAJOR}" "${MINOR}"
            chown "${UID}:${GID}" "${PTH}"
          fi
        fi
        ;;

      "c+")

        # Create a character device node if it does not exist yet. If suffixed
        # with + and a file already exists where the device node is to be
        # created, it will be removed and be replaced by the device node.

        if [ -e "${PTH}" ] || [ -L "${PTH}" ]; then
          rm -f "${PTH}"
        fi
        if [ "${ARG}" ]; then
          MAJOR=`echo ${ARG} | cut -d ':' -f 1`
          MINOR=`echo ${ARG} | cut -d ':' -f 2`
          [ -z "${MOD}" ] && MOD="0644"
          [ -z "${UID}" ] && UID="root"
          [ -z "${GID}" ] && GID="root"
          mknod -m "${MOD}" "${PTH}" c "${MAJOR}" "${MINOR}"
          chown "${UID}:${GID}" "${PTH}"
        fi
        ;;

      "b")

        # Create a block device node if it does not exist yet.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          if [ "${ARG}" ]; then
            MAJOR=`echo ${ARG} | cut -d ':' -f 1`
            MINOR=`echo ${ARG} | cut -d ':' -f 2`
            [ -z "${MOD}" ] && MOD="0644"
            [ -z "${UID}" ] && UID="root"
            [ -z "${GID}" ] && GID="root"
            mknod -m "${MOD}" "${PTH}" b "${MAJOR}" "${MINOR}"
            chown "${UID}:${GID}" "${PTH}"
          fi
        fi
        ;;

      "b+")

        # Create a block device node if it does not exist yet. If suffixed
        # with + and a file already exists where the device node is to be
        # created, it will be removed and be replaced by the device node.

        if [ -e "${PTH}" ] || [ -L "${PTH}" ]; then
          rm -f "${PTH}"
        fi
        if [ "${ARG}" ]; then
          MAJOR=`echo ${ARG} | cut -d ':' -f 1`
          MINOR=`echo ${ARG} | cut -d ':' -f 2`
          [ -z "${MOD}" ] && MOD="0644"
          [ -z "${UID}" ] && UID="root"
          [ -z "${GID}" ] && GID="root"
          mknod -m "${MOD}" "${PTH}" b "${MAJOR}" "${MINOR}"
          chown "${UID}:${GID}" "${PTH}"
        fi
        ;;

      "C")

        # Recursively copy a file or directory, if the destination files or
        # directories do not exist yet. Note that this command will not
        # descend into subdirectories if the destination directory already
        # exists. Instead, the entire copy operation is skipped. If the argument
        # is omitted, files from the source directory /usr/share/factory/
        # with the same name are copied.

        if [ ! -e "${PTH}" ] && [ ! -L "${PTH}" ]; then
          if [ "${ARG}" ]; then
            if [ -e "${ARG}" ] || [ -L "${ARG}" ]; then
              cp -R "${ARG}" "${PTH}"
            fi
          fi
        fi
        ;;

      "x")
        ;;

      "X")
        ;;

      "r")

        # Remove a file or directory if it exists. This may not be used to
        # remove non-empty directories, use R for that. Lines of this type
        # accept shell-style globs in place of normal path names.

        if [ -d "${PTH}" ]; then
          rmdir "${PTH}"
        elif [ -e "${PTH}" ] || [ -L "${PTH}" ]; then
          rm -f "${PTH}"
        fi
        ;;

      "R")

        # Recursively remove a path and all its subdirectories (if it is
        # a directory). Lines of this type accept shell-style globs in place
        # of normal path names.

        if [ -e "${PTH}" ] || [ -L "${PTH}" ]; then
          rm -rf "${PTH}"
        fi
        ;;

      "z")

        # Adjust the access mode, group and user, and restore the SELinux
        # security context of a file or directory, if it exists. Lines of
        # this type accept shell-style globs in place of normal path names.

        if [ -e "${PTH}" ]; then
          if [ "${MOD}" ]; then
            chmod "${MOD}" "${PTH}"
          fi
          if [ "${UID}" ]; then
            chown "${UID}" "${PTH}"
          fi
          if [ "${GID}" ]; then
            chown :"${GID}" "${PTH}"
          fi
        fi
        ;;

      "Z")

        # Recursively set the access mode, group and user, and restore the
        # SELinux security context of a file or directory if it exists,
        # as well as of its subdirectories and the files contained therein
        # (if applicable). Lines of this type accept shell-style globs in place
        # of normal path names.

        if [ -e "${PTH}" ]; then
          if [ "${MOD}" ]; then
            chmod -R "${MOD}" "${PTH}"
          fi
          if [ "${UID}" ]; then
            chown -R "${UID}" "${PTH}"
          fi
          if [ "${GID}" ]; then
            chown -R :"${GID}" "${PTH}"
          fi
        fi
        ;;

      *)
        echo "error: unknown type ${TYP}"
        ;;

    esac
  done
done
